package TP3;
import java.util.Random; // N'oubliez pas l'import au début du fichier

public class QuatreCoinDuMonde {

	private int taille = 10;
	private Entites[][] map;
	private Entites[] entites;
    Random rand = new Random();

	public QuatreCoinDuMonde() {
	    this.map = new Entites[taille][taille];

	    // 1. Liste des Graals
	    Entites[] listeGraals = {
	        new Graal("excalibur", 100, 5, "E"),
	        new Graal("fal lial", 80, 4, "F"),
	        new Graal("lance lug", 40, 2, "L"),
	        new Graal("Chaudron_connaissance", 50, 3, "c")
	    };

	    // Placement des Graals (Sauf sur x = 0)
	    for (Entites g : listeGraals) {
	        int x, y;
	        do {
	            // (taille - 1) donne un nombre entre 0 et 8. 
	            // En ajoutant 1, on obtient entre 1 et 9.
	            x = rand.nextInt(taille - 1) + 1; 
	            y = rand.nextInt(taille);
	        } while (map[x][y] != null); 
	        map[x][y] = g;
	    }

	    // 2. Placement des Obstacles (Sauf sur x = 0)
	    int nbObstaclesVoulus = 10; 
	    for (int i = 0; i < nbObstaclesVoulus; i++) {
	        int x, y;
	        do {
	            x = rand.nextInt(taille - 1) + 1; // Interdit le 0
	            y = rand.nextInt(taille);
	        } while (map[x][y] != null);

	        int typeAleatoire = rand.nextInt(3);
	        if (typeAleatoire == 0) map[x][y] = new Obstacles("roche", 10, "r");
	        else if (typeAleatoire == 1) map[x][y] = new Obstacles("ronces", 10, "R");
	        else map[x][y] = new Obstacles("puits", 10, "P");
	    }
	}
	public void ajouter(Chevalier c) {
	    int x, y;
	    Random rand = new Random(); // Assurez-vous que rand est bien initialisé
	    do {
	        // X peut être n'importe où (de 0 à taille-1)
	        x = rand.nextInt(taille);
	        
	        // Y doit être entre 1 et taille-1 (pour éviter la colonne 0)
	        // La formule : rand.nextInt(max - min) + min
	        // Ici : rand.nextInt(taille - 1) + 1 donne entre 1 et 9 (si taille = 10)
	        y = rand.nextInt(taille - 1) + 1;
	        
	    } while (map[x][y] != null); // On cherche une case vide

	    map[x][y] = c;
	    c.setPosition(x, y);
	}
	
	
	public void seDeplacer(Chevalier c) {
	    int ancienneX = c.getX();
	    int ancienneY = c.getY();
	    
	    // Déterminer le mouvement (-1, 0 ou 1)
	    // Ici on s'assure que dx et dy ne sont pas toujours bloqués sur -1 ou 1
	    int dx = (Math.random() < 0.5) ? -1 : 1;
	    int dy = (Math.random() < 0.5) ? -1 : 1;

	    // --- CALCUL DE X (Lignes : de 0 à taille-1) ---
	    // On ajoute 'taille' avant le modulo pour éviter les nombres négatifs
	    int nouvelleX = (ancienneX + dx + taille) % taille;

	    // --- CALCUL DE Y (Colonnes : INTERDIT l'index 0, donc de 1 à taille-1) ---
	    // On travaille sur une largeur effective de (taille - 1)
	    int largeurUtile = taille - 1; 
	    int nouvelleY = ((ancienneY - 1 + dy + largeurUtile) % largeurUtile) + 1;

	    // --- SÉCURITÉ : On efface l'ancienne position seulement si elle a changé ---
	    if (ancienneX != nouvelleX || ancienneY != nouvelleY) {
	        map[ancienneX][ancienneY] = null;
	    }

	    // Interaction avec le contenu de la nouvelle case
	    if (map[nouvelleX][nouvelleY] != null) {
	        if (map[nouvelleX][nouvelleY] instanceof Obstacles) {
	            c.setPv(c.getPv() - map[nouvelleX][nouvelleY].getPv());
	            System.out.println("Obstacle touché ! PV : " + c.getPv());
	        } 
	        else if (map[nouvelleX][nouvelleY] instanceof Graal) {
	            c.setPv(c.getPv() + map[nouvelleX][nouvelleY].getPv());
	            c.setBag(map[nouvelleX][nouvelleY]);
	            System.out.println("Graal récupéré : ");
	        }
	    }

	    // Mise à jour de la map et de l'objet Chevalier
	    map[nouvelleX][nouvelleY] = c;
	    c.setPosition(nouvelleX, nouvelleY);
	}
	//afficher
	public String toString() {
	    String res = "  "; // Espace pour décaler la première ligne
	    
	    // 1. Afficher les numéros de colonnes en haut (Ligne 0 virtuelle)
	    for (int y = 0; y < taille; y++) {
	        res += y + " ";
	    }
	    res += "\n";

	    for (int i = 0; i < taille; i++) {
	        // 2. Afficher le numéro de la ligne au début
	        res += i + " "; 
	        
	        for (int y = 0; y < taille; y++) {
	            // 3. Afficher le contenu de la map
	            if (map[i][y] != null) {
	                res += map[i][y].recupInitial() + " ";
	            } else {
	                res += ". ";
	            }
	        }
	        res += "\n";
	    }
	    return res;
	}